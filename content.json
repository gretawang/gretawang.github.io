{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/02/03/hello-world/"},{"title":"My New Post","text":"","link":"/2021/02/03/My-New-Post/"},{"title":"My first blog","text":"This is my new blog, I hope you like it.","link":"/2021/02/03/%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/"},{"title":"RabbitMQ - What is RabbitMQ?","text":"What’s RabbitMQ?RabbitMQ is a message broker, also known as message manager, which is used to accept and forward messages. You can think RabbitMQ as a mail posting system. When you want to post a mail, you put it into the post box. The postman will take care of it. Eventually, the mail will be sent to your recipient. In this analogy, RabbitMQ first works as the post box which accepts the message(mail), then it works as the post office which dispatches the message, and at last it works as the postman who deliveries the message to its recipient. In RabbitMQ, there are some jargon. Producer: A program or service which sends messages is called a producer. Queue: The queue, which works like the post box, lives inside the RabbitMQ. Producers put messages to the Queue, and consumers try to receive messages from it. Consumer: A program or service which waits to receive messages is called consumer. It is quite easy to set RabbitMQ runtime environment. The only thing you need to do is following the instructions in this link Downloading and Installing RabbitMQ . Hello World(Using the Java Client)In this section, we will write two services in Java: a producer which sends a single message, and a consumer which waits to receive the message and prints it out.","link":"/2021/02/03/Instance%20Initializer%20Block%20in%20Java%20and%20Its%20Invoked%20Order/"},{"title":"RabbitMQ - Relationship between channel and connection","text":"If you have some experiences of using RabbitMQ, you would know to publish or consume messages to RabbitMQ server, we need to do: We need to connect to a RabbitMQ instance. This is a TCP based connection. We need to get a virtual connection(called channel) inside the TCP connection. 123456789ConnectionFactory factory = new ConnectionFactory();factory.setHost(&quot;localhost&quot;);try (Connection connection = factory.newConnection(); Channel channel = connection.createChannel()) { channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = &quot;Hello World!&quot;; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;);} A connection is a real long-lived TCP to the message broker. Channels share a single TCP connection, which can be thought as “lightweight” or “virtual” connections. Most of the API for getting things done resides in the Channel . The question is Why only TCP connection is insufficient? Let’s assume, we do not have the Channel. In multi-thread architecture, you may need a separate connection per thread. It may lead to overloading the broker with TCP connections. Instead of using TCP connection directly, channel creates virtual connections inside a TCP connection. In this way, we can use as many threads as we want to communicate with the broker, at the same time, without overloading the broker with TCP connections. In summary, some applications need multiple connections to the broker. AMQP are multiplexed with channels. This is how Connections and Channels are related in RabbitMQ. Hope this short article help you understand these two different concepts.","link":"/2021/03/15/RabbitMQ%20-%20Relationship%20between%20channel%20and%20connection/"}],"tags":[],"categories":[]}