{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/02/03/hello-world/"},{"title":"My New Post","text":"","link":"/2021/02/03/My-New-Post/"},{"title":"My first blog","text":"This is my new blog, I hope you like it.","link":"/2021/02/03/%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/"},{"title":"RabbitMQ - What is RabbitMQ?","text":"What’s RabbitMQ?RabbitMQ is a message broker, also known as message manager, which is used to accept and forward messages. You can think RabbitMQ as a mail posting system. When you want to post a mail, you put it into the post box. The postman will take care of it. Eventually, the mail will be sent to your recipient. In this analogy, RabbitMQ first works as the post box which accepts the message(mail), then it works as the post office which dispatches the message, and at last it works as the postman who deliveries the message to its recipient. In RabbitMQ, there are some jargon. Producer: A program or service which sends messages is called a producer. Queue: The queue, which works like the post box, lives inside the RabbitMQ. Producers put messages to the Queue, and consumers try to receive messages from it. Consumer: A program or service which waits to receive messages is called consumer. It is quite easy to set RabbitMQ runtime environment. The only thing you need to do is following the instructions in this link Downloading and Installing RabbitMQ . Hello World(Using the Java Client)In this section, we will write two services in Java: a producer which sends a single message, and a consumer which waits to receive the message and prints it out.","link":"/2021/02/03/Instance%20Initializer%20Block%20in%20Java%20and%20Its%20Invoked%20Order/"},{"title":"RabbitMQ - Relationship between channel and connection","text":"If you have some experiences of using RabbitMQ, you would know to publish or consume messages to RabbitMQ server, we need to do: We need to connect to a RabbitMQ instance. This is a TCP based connection. We need to get a virtual connection(called channel) inside the TCP connection. 123456789ConnectionFactory factory = new ConnectionFactory();factory.setHost(&quot;localhost&quot;);try (Connection connection = factory.newConnection(); Channel channel = connection.createChannel()) { channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = &quot;Hello World!&quot;; channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes()); System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;);} A connection is a real long-lived TCP to the message broker. Channels share a single TCP connection, which can be thought as “lightweight” or “virtual” connections. Most of the API for getting things done resides in the Channel . The question is Why only TCP connection is insufficient? Let’s assume, we do not have the Channel. In multi-thread architecture, you may need a separate connection per thread. It may lead to overloading the broker with TCP connections. Instead of using TCP connection directly, channel creates virtual connections inside a TCP connection. In this way, we can use as many threads as we want to communicate with the broker, at the same time, without overloading the broker with TCP connections. In summary, some applications need multiple connections to the broker. AMQP are multiplexed with channels. This is how Connections and Channels are related in RabbitMQ. Hope this short article help you understand these two different concepts.","link":"/2021/03/15/RabbitMQ%20-%20Relationship%20between%20channel%20and%20connection/"},{"title":"RabbitMQ Exchanges, routing keys and bindings","text":"Talking about the Exchange, the most confusing concepts are “Binding key” and “Routing key”. We explain the two concepts first. ① The routing key is a message attribute the exchange looks at when deciding how to route(send) the message to the queue. ② The binding key is a queue attribute. It is the key that the queue used to register itself to the exchange. Bindings can be seen as a process of matching the message with the queue. To make things worse, the RabbitMQ APIs use the same parameter name “routing key” to say these two different concepts in different methods. Now we check two examples of the RabbitMQ API definitions which means different concepts but uses the same parameter name. ① The method definition of basicPublish of the class com.rabbitmq.clien.Channel: 1void basicPublish​(String exchange, String routingKey, boolean mandatory, AMQP.BasicProperties props, byte[] body) throws IOException The method is used to publish messages. The second parameter of this method is routingKey which is a message attribute. ② Another method that uses routingKey as one of its parameters is queueBind of class com.rabbitmq.clien.Channel. 1AMQP.Queue.BindOk queueBind​(String queue, String exchange, String routingKey, Map&lt;String,​Object&gt; arguments) throws IOException The method is used to bind a queue to an exchange. The parameter routingKey here is a queue attribute. The Java tutorial from the RabbitMQ team attempts to explain it in the following words: A binding is a relationship between an exchange and a queue. This can be simply read as: the queue is interested in messages from this exchange. Bindings can take an extra routingKey parameter. To avoid the confusion with a basicPublish parameter we’re going to call it a binding key.","link":"/2021/03/16/2021-03-16%20RabbitMQ%20-%20Exchange/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"}],"categories":[]}